
Enum "comment_type_enum" {
  "plain"
  "picture"
  "video"
}

Table "comment" {
  "id" int [pk, not null, increment]
  "content" varchar(128) [not null, note: 'can be plain text, url']
  "type" comment_type_enum [not null]
  "author" int [not null]
  "parent_type" tinyint(1) [default: 0, note: '0: post parent; 1: comment parent']
  "parent" int [not null, note: 'the id of which the comment replay to, can be post or comment']
  "child_count" int [default: 0]
  "likes" int [default: 0]
  "dislikes" int [default: 0]
  "is_delete" tinyint(1) [default: 0]
  "create_at" datetime [default: 'now()']
  "update_at" datetime [default: 'now()']
  Note: 'integrated comment on post and comment on comment, support nested comments'
}

Table "message" {
  "id" int [pk, not null, increment]
  "sender" int [not null]
  "receiver" int [not null]
  "content" varchar(128) [not null]
  "is_read" tinyint(1) [default: 0]
  "create_at" datetime [default: 'now()']
}

Table "post" {
  "id" int [pk, not null, increment]
  "title" varchar(128) [not null]
  "author" int [not null]
  "comment_count" int [default: 0]
  "likes" int [default: 0]
  "dislikes" int [default: 0]
  "is_delete" tinyint(1) [default: 0]
  "create_at" datetime [default: 'now()']
  "update_at" datetime [default: 'now()']
  Note: '''post is different from comment, for it is required to search posts fast, but it doesn\\\'t matter if user wait when loading the posts\\\' details'''
}

Table "ref_follow" {
  "id" int [pk, not null, increment]
  "following" int [default: NULL]
  "follower" int [default: NULL]
  "is_delete" tinyint(1) [default: 0]

  Indexes {
    (following, follower) [type: btree, unique, name: "ref_follow_index_1"]
  }
}

Table "ref_post_tag" {
  "id" int [pk, not null, increment]
  "post_id" int [default: NULL]
  "tag_id" int [default: NULL]
  "is_delete" tinyint(1) [default: 0]

  Indexes {
    (post_id, tag_id) [type: btree, unique, name: "ref_post_tag_index_0"]
  }
}

Table "tag" {
  "id" int [pk, not null, increment]
  "content" varchar(64) [not null]
  Note: 'tag can be filters and traced, so it is required to be an independent table'
}

Table "user" {
  "id" int [pk, not null, increment]
  "username" varchar(32) [not null]
  "password" varchar(64) [not null, note: 'encrypted by bcrypt, salting, 60']
  "school" varchar(32) [not null]
  "phone" varchar(32) [not null]
  "pub_key" varchar(512) [default: NULL, note: 'generated by RSA, base64 encoded']
  "is_delete" tinyint(1) [default: 0]
  "create_at" datetime [default: 'now()']
  "update_at" datetime [default: 'now()']
  "hide_until" datetime [default: `CURRENT_TIMESTAMP`]
  Note: 'when registering, user must provide its session id. Once session validation passed, use session id to generate a pair of keys'
}

Table "util_session_key" {
  "user_a" int [pk, not null]
  "user_b" int [not null]
  "key_a" varchar(512) [default: NULL]
  "key_b" varchar(512) [default: NULL]

  Indexes {
    (user_a, user_b) [type: btree, unique, name: "recipient"]
  }
}

Ref: user.id < comment.author

Ref: user.id - util_session_key.user_a
Ref: user.id - util_session_key.user_b

Ref: user.id < post.author

Ref: user.id < message.sender
Ref: user.id < message.receiver

Ref: post.id < ref_post_tag.post_id
Ref: tag.id < ref_post_tag.tag_id

Ref: user.id < ref_follow.following
Ref: user.id < ref_follow.follower

Ref: comment.parent - comment.id
Ref: comment.parent - post.id